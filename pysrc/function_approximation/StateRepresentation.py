# !/usr/bin/env python


from constants import *
import numpy as np
import pickle
# We want the hashing for tiles to be deterministic. So set random seed.
import random
random.seed(9000)
from pysrc.function_approximation.tiles import *

# image tiles
NUMBER_OF_PIXEL_SAMPLES = 100
CHANNELS = 4
NUM_IMAGE_TILINGS = 4
NUM_IMAGE_INTERVALS = 4
SCALE_RGB = NUM_IMAGE_INTERVALS / 256.0

IMAGE_START_INDEX = 0

# constants relating to image size recieved
IMAGE_HEIGHT = HEIGHT  # rows
IMAGE_WIDTH = WIDTH  # columns

NUMBER_OF_COLOR_CHANNELS = 3  # red, blue, green
PIXEL_FEATURE_LENGTH = np.power(NUM_IMAGE_INTERVALS, NUMBER_OF_COLOR_CHANNELS) * NUM_IMAGE_TILINGS
PREDICTION_FEATURE_LENGTH = 16
DID_TOUCH_FEATURE_LENGTH = 1
NUMBER_OF_GVFS = 10
NUMBER_OF_ACTIONS = 4
NUM_PREDICTION_TILINGS = 4
# TOTAL_FEATURE_LENGTH =NUMBER_OF_ACTIONS * (PIXEL_FEATURE_LENGTH * NUMBER_OF_PIXEL_SAMPLES + NUMBER_OF_GVFS * PREDICTION_FEATURE_LENGTH) + DID_TOUCH_FEATURE_LENGTH
TOTAL_FEATURE_LENGTH = PIXEL_FEATURE_LENGTH * NUMBER_OF_PIXEL_SAMPLES + DID_TOUCH_FEATURE_LENGTH + 1
# TOTAL_FEATURE_LENGTH -= NUMBER_OF_GVFS*PREDICTION_FEATURE_LENGTH*NUMBER_OF_ACTIONS
# Channels
RED_CHANNEL = 0
GREEN_CHANNEL = 1
BLUE_CHANNEL = 2
DEPTH_CHANNEL = 3

WALL_THRESHOLD = 0.2  # If the prediction is greater than this, the pavlov agent will avert


class Representation(object):

    def __init__(self,
                 _dimensions=PIXEL_FEATURE_LENGTH * NUMBER_OF_PIXEL_SAMPLES + DID_TOUCH_FEATURE_LENGTH):
        """
        Args:
            _dimensions (int): the number of inputs from the environment
            _startingPrototypes (int): the number of features generated by the network
            non_linearity (int): the non-linearity applied to the ANN
            """
        # initialize the parameters of a neural network
        self.dimensions = _dimensions + 1
        self.num_features = _dimensions + 1   # this is to account for the bias unit
        self.numPrototypes = self.num_features
        self.phi = None

        self.pointsOfInterest = []
        self.numberOfTimesBumping = 0
        self.randomYs = np.random.choice(HEIGHT, NUMBER_OF_PIXEL_SAMPLES, replace=True)
        self.randomXs = np.random.choice(WIDTH, NUMBER_OF_PIXEL_SAMPLES, replace=True)

        for i in range(NUMBER_OF_PIXEL_SAMPLES):
            point = self.randomXs[i], self.randomYs[i]
            self.pointsOfInterest.append(point)

    def get_num_active(self):
        return 405

    def save_points_of_interest(self, file_name):
        """Saves the subsampled pixel locations to a file.
        Args:
            file_name (str): the location of the file to save points of interest to.
        """
        with open(file_name, 'wb') as outfile:
            pickle.dump(self.pointsOfInterest, outfile)

    def read_points_of_interest(self, file_name):
        """Reads the subsampled pixel locations from a
        Args:
            file_name (str): the name of the file to be read.
        """
        with open(file_name, 'rb') as inFile:
            self.pointsOfInterest = pickle.load(inFile)
            print("Read points of interest")

    def get_rgb_pixel_from_frame(self, frame, x, y):
        """Given a frame and some x,y pixel location, extracts the rgb value of the given pixel.

        Args:
            frame (???): a current minecraft frame
            x (int): the x location of the pixel of interest
            y (int): the y location of the pixel of interest

        Returns:
            (r, g, b) (tuple): the r,g,b values for the pixel of interest.
        """
        r = frame[3 * (x + y * WIDTH)]
        g = frame[1 + 3 * (x + y * WIDTH)]
        b = frame[2 + 3 * (x + y * WIDTH)]
        return (r, g, b)

    @staticmethod
    def get_empty_phi():
        return np.zeros(TOTAL_FEATURE_LENGTH)

    def get_features(self, obs):
        """
            Name: get_phi
            Description: Creates the feature representation (phi) for a given observation. The representation
              created by individually tile coding each NUMBER_OF_PIXEL_SAMPLES rgb values together, and then assembling them.
              Finally, the didBump value is added to the end of the representation. didBump is determined to be true if
              the closest pixel in view is less than PIXEL_DISTANCE_CONSIDERED_BUMP
            Input: the observation. This is the full pixel rgbd values for each of the IMAGE_WIDTH X IMAGE_HEIGHT pixels in view
            Output: The feature vector
            """

        if not obs:
            return None

        try:
            frame = obs['visionData']
        except KeyError:
            return self.get_empty_phi()  # if there is no frame, return an empty feature vector.

        phi = [1]   # bias bit.
        # For the points we are subsampling into our representation...
        for point in self.pointsOfInterest:
            # Get the pixel value at that point
            x = point[0]
            y = point[1]
            red, green, blue = self.get_rgb_pixel_from_frame(frame, x, y)
            red = red / 256.0
            green = green / 256.0
            blue = blue / 256.0

            pixel_rep = np.zeros(PIXEL_FEATURE_LENGTH)
            # Tile code these 3 values together
            indexes = tiles(NUM_IMAGE_TILINGS, PIXEL_FEATURE_LENGTH, [red, green, blue])
            pixel_rep[indexes] = 1.0
            # Assemble with other pixels
            phi.extend(pixel_rep)

            # if there are predictions in the representation, tile them in!
        if obs['predictions'] is not None:
            for prediction in obs['predictions']:
                prediction_rep = np.zeros(PREDICTION_FEATURE_LENGTH)
                indexes = tiles(NUM_PREDICTION_TILINGS, 16, [prediction])
                prediction_rep[indexes] = 1.0
                phi.extend(prediction_rep)
        did_touch = obs['touchData']
        phi.append(float(did_touch))
        return np.array(phi)


class TrackingRepresentation(Representation):

    def __init__(self, **args):
        self.dimensions = PIXEL_FEATURE_LENGTH * NUMBER_OF_PIXEL_SAMPLES + DID_TOUCH_FEATURE_LENGTH + 1
        self.num_features = self.dimensions
        self.phi = np.zeros(self.num_features)
        self.phi[np.random.choice(range(self.num_features), size=405)] = 1

    def get_num_active(self):
        return 407

    def get_features(self, obs):
        return self.phi


class Bias(Representation):

    def __init__(self, **args):
        self.dimensions = 1
        self.num_features = 1

    def get_num_active(self):
        return 1

    def get_features(self, obs):
        return np.array([1])

